1. const int a = 10 和int a = 10 这两个参数存储到哪里
* 编译器进行常量传播之后，优化掉了
```

BSS段存放的是未初始化的普通全局变量、静态局部变量、静态全局变量，
DATA段存放的是已初始化的普通全局变量、静态局部变量、静态全局变量，其中DATA段又分为只读段和可读可写段。

现代编译器中关键字const修饰的全局变量、静态局部变量变量和静态全局变量就是存放在DATA段中的只读段，所以这些变量为只读属性，
其值通过指针也不可改变。而const修饰的局部变量存放在栈中，可以通过指针改变其值。

```


2. x86_64的大页有两种模式：2MB 和 1GB(配置大型数据库，性能会提高很大)标准 HugePages 内存在启动时预先分配，在运行时不会更改。
* 大页的优势：大页内存TLB miss 很少，缺页中断也很少，极高的提高了性能，对于那些内存操作非常频繁的业务来说，可以有效的提高性能。
* 大页的劣势：大页导致的页内碎片会更严重。另外如果你只修改大页中的一小块内容，但是大页被换出到交换区，此时整个大页都需要换入到内存，很耗时

3. 动态连接过程中第三方库的处理
* 第三方库函数在连接时使用延迟绑定技术，通过PLT(procedure linkage table)来结构来进行跳转，
```c
//bash执行elf文件的过程：fork一个进程，进程调用execve()系统调用, execve()系统调用执行load_elf_binary()函数加载elf文件(就是把elf文件映射到进行的地址空间)，
//然后将系统调用的返回地址修改为ELF可执行文件的入口点(静态链接：入口就是ELF文件的".e_entry"段的地址， 动态链接：入口就是动态连接器),系统调用返回跳转到ELF程序的入口地址开始执行。

/*
elf将got表分成了两个表：
".got" ：保存全局变量引用的地址
".gotplt" ： 保存函数引用的地址(包括第三方库函数)----PLT延迟绑定技术

*/

```

4. 
