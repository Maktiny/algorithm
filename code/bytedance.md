1. c++的智能指针

2. elf格式的文件怎么加载的

3. 动静态链接是怎么做的

4. 析构函数为什么是虚函数

5. 32的ABI中，函数参数是通过栈来传递的参数， 64位中是先用RDI,RSI, RDX等八个寄存器传值，多余的参数从右往左入栈
在x86-32中，使用寄存器传递用于Linux系统调用的参数。 %eax表示syscall_number。 ％ebx，％ecx，％edx，％esi，％edi，％ebp用于将6个参数传递给系统调用。
返回值在%eax中。所有其他寄存器（包括EFLAGS）在int $0x80中保留
(用户态的函数调用传参 和 系统调用传参 是不一样的)
![参考](http://string.quest/read/15644901)

6. 造成缺页异常的几种情况，每种情况是怎么处理的
* 延迟分配页
* 写时复制
* 访问的页交换到磁盘

7. 什么是页缓存

8. std::map 和std::unordered_map的区别， 如果把类对象作为key放入map中,由于map中的key是有序的，所以需要对"<"小于符号进行重载。

9. 进程和协程的区别
* 协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费
* 线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃
* 线程的栈最大8 MB，而协程栈的大小通常只有 KB(由用户在堆上分配协程栈)
* 运行中的协程将占有当前线程的所有计算资源
* 协程的所有信息都保存在上下文（Contex）对象中，将不同上下文分发给不同的线程就可以实现协程的跨线程执行，如此，协程被阻塞的概率将减小
* 同样因为调度与资源的限制，有效协程的数量也是有上限的



10. 进程间的同步

int (*a)(int) ; 
int (*a[10])(int); 
int *(*a)(int) ; 
几个定义的含义？

int (*a)(int) ; //a是一个指针,它指向带有int形参并返回int类型的函数,即a是函数指针 
int (*a[10])(int); //a是一个数组,数组有10个指针.这里的指针和上面a是一样的. 
int *(*a)(int) ; //a是一个指针,它指向带有int形参并返回int*类型的函数

